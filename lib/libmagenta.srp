# libmagenta
require "libstd"
require "libmidi"
require "debug"
require "sched"
require "mfread"

# in unit of beat
fetching_period = 0.5
note_queue = Queue()
minimum_queue_size = 120

RNN_flag = 0
def request_RNN():
    if RNN_flag == 0:
        display "request_RNN", the_sched.time
        RNN_flag = 1
        # TODO: construct request
        system("./a.sh &")
        rtsched.cause(fetching_period, nil, 'get_RNN')
    return

def get_RNN():
    display "get_RNN", the_sched.time
    # check if filesystem has midi file and read file
    var f = open("test.mid", "r")
    if f is nil:
        rtsched.cause(fetching_period, nil, 'get_RNN')
    else:
        # TODO: just testing here
        var note_list = parse_smf("test.mid")
        note_queue.push_list(note_list)
        # TODO: delete file
        system("mv test.mid test_.mid")
        RNN_flag = 0
        display note_queue.size()
        if note_queue.size() < minimum_queue_size:
            rtsched.cause(0, nil, 'request_RNN')

def fit_measure():
    display "fit_measure", the_sched.time
    # fetch notes from global note_queue and fit to chord, style, scale
    # returns a Measure instance
    # TODO: just testing here
    var measure = Measure(4, 4)
    if note_queue.size() < 4:
        return nil
    for i = 0 to 4:
        measure.add_note(note_queue.pop())
    if note_queue.size() < minimum_queue_size:
        rtsched.cause(0, nil, 'request_RNN')

    return measure

def fit_and_play(midi):
    display "fit_and_play", the_sched.time
    the_sched.cause(4, nil, 'fit_and_play', midi)
    var measure = fit_measure()
    if measure is not nil:
        measure.play(midi, 0)


def parse_smf(file):
    var smf_bpm = 120.0
    var smf_tempo = 60.0 / smf_bpm
    smf_reader = Midifile_reader(file)
    var res = []
    var note_list = smf_reader.seq.tracks[1]
    var note_time = 0
    for i = 1 to len(note_list):
        var smf_note = note_list[i]
        display smf_note.time, note_time
        if smf_note.time > note_time:
            var last_idx = len(res) - 1
            res[last_idx].duration = res[last_idx].duration + (smf_note.time - note_time) / smf_tempo
        res.append(Note(smf_note.key, smf_note.dur / smf_tempo))
        note_time = smf_note.time + smf_note.dur
    return res

# ################ TEST ###################
# res = parse_smf("test.mid")
# for i = 0 to len(res):
#     display i, res[i].pitch, res[i].duration

