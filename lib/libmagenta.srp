# libmagenta
require "libstd"
require "libmidi"
require "debug"
require "sched"
require "mfread"

# in unit of beat
fetching_period = 0.5
note_queue = Queue()
minimum_queue_size = 120

def get_command(num_outputs, num_steps, primer_melody):
    display "get_command", num_outputs, num_steps
    var melody_str = ""
    var note_list = []
    while primer_melody.notes.size() > 0:
        display primer_melody.notes.size(), len(note_list)
        note_list.append(primer_melody.notes.pop())
    display "loop end"
    display len(note_list)
    for i = 0 to len(note_list):
        var note_ = note_list[i]
        melody_str = melody_str + str(note_.pitch) + ","
        for j = 1 to note_.duration / 0.25:
            melody_str = melody_str + "-2,"
    melody_str = "[" + subseq(melody_str, 0, -1) + "]"
    display melody_str

    var retval = ""
    retval = retval + "melody_rnn_generate "
    retval = retval + "--config=lookback_rnn "
    retval = retval + "--bundle_file=/Users/yanmengjin1/software/lookback_rnn.mag "
    retval = retval + "--output_dir= ./ "
    retval = retval + "--num_outputs=" + str(num_outputs) + " "
    retval = retval + "--num_steps=" + str(num_steps) + " "
    retval = retval + "--primer_melody=" + melody_str

    display retval
    return retval

RNN_flag = 0
def request_RNN():
    if RNN_flag == 0:
        display "request_RNN", the_sched.time
        RNN_flag = 1
        # TODO: construct request
        system("./a.sh &")
        rtsched.cause(fetching_period, nil, 'get_RNN')
    return

def get_RNN():
    display "get_RNN", the_sched.time
    # check if filesystem has midi file and read file
    var f = open("test.mid", "r")
    if f is nil:
        rtsched.cause(fetching_period, nil, 'get_RNN')
    else:
        # TODO: just testing here
        var note_list = parse_smf("test.mid")
        note_queue.push_list(note_list)
        # TODO: delete file
        system("mv test.mid test_.mid")
        RNN_flag = 0
        display note_queue.size()
        if note_queue.size() < minimum_queue_size:
            rtsched.cause(0, nil, 'request_RNN')

def fit_measure():
    display "fit_measure", the_sched.time
    # fetch notes from global note_queue and fit to chord, style, scale
    # returns a Measure instance
    # TODO: just testing here
    var measure = Measure(4, 4)
    if note_queue.size() < 4:
        return nil
    for i = 0 to 4:
        measure.add_note(note_queue.pop())
    if note_queue.size() < minimum_queue_size:
        rtsched.cause(0, nil, 'request_RNN')

    return measure

def fit_and_play(midi):
    display "fit_and_play", the_sched.time
    the_sched.cause(4, nil, 'fit_and_play', midi)
    var measure = fit_measure()
    if measure is not nil:
        measure.play(midi, 0)


def parse_smf(file):
    var smf_bpm = 120.0
    var smf_tempo = 60.0 / smf_bpm
    smf_reader = Midifile_reader(file)
    var res = []
    var note_list = smf_reader.seq.tracks[1]
    var note_time = 0
    for i = 1 to len(note_list):
        var smf_note = note_list[i]
        # display smf_note.time, note_time
        if smf_note.time > note_time:
            var last_idx = len(res) - 1
            res[last_idx].duration = res[last_idx].duration + (smf_note.time - note_time) / smf_tempo
        res.append(Note(smf_note.key, smf_note.dur / smf_tempo))
        note_time = smf_note.time + smf_note.dur
    return res

# ################ TEST ###################
# res = parse_smf("test.mid")
# for i = 0 to len(res):
#     display i, res[i].pitch, res[i].duration
notelist = parse_smf("test.mid")
queue = Queue()
queue.push_list(notelist)
lastnotes = queue.last_n(10)

while queue.size() > 0:
    var note_ = queue.pop()
    display note_.pitch, note_.duration

m = Measure(4,4)
for i = 1 to 10:
    m.add_note(lastnotes[i])
get_command(2, 120, m)


