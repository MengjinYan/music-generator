# libmidi - Basic Operations of Midi

midi_status_note_off = 0x80
midi_status_note_on = 0x90
midi_status_key_pressure = 0xa0
midi_status_controller_change = 0xb0
midi_status_program_change = 0xc0
midi_status_channel_pressure = 0xd0
midi_status_pitch_bend = 0xe0

class Midi:
    var _midi_id
    var _buf
    var _latency
    var _midi

    def init(midi_id, buf, latency):
        _midi_id = midi_id
        _buf = buf
        _latency = latency
        _midi = midi_create()
        midi_open_output(_midi, _midi_id, _buf, _latency)

    def note_on(channel, pitch, velocity):
        channel = channel & 15
        midi_write(_midi, 0, chr(midi_status_note_on + channel) + chr(pitch) + chr(velocity))

    def note_off(channel, pitch):
        channel = channel & 15
        midi_write(_midi, 0, chr(midi_status_note_on + channel) + chr(pitch) + chr(0))
    
    def close():
        midi_close(_midi)


class Note:
    var pitch
    # proportion of the note in a measure
    # 0 < duration <= 1, quater note: duration = 1/4
    var duration
    # time till the note is played, for the usage of graphics
    var graphic_time
    var velocity
    var _channel

    def init(pitch_, duration_):
        pitch = pitch_
        duration = duration_

    def play(midi):
        midi.note_on(_channel, pitch, velocity)

    def play_offset(midi, pitch_offset, volume):
        midi.note_on(_channel, pitch + pitch_offset, volume)

    def stop(midi):
        midi.note_off(_channel, pitch)

pitch_map = {"C": 0, "Db": 1, "D": 2, "Eb": 3, "E": 4, "F": 5, "Gb": 6, "G": 7, "Ab": 8, "A": 9, "Bb": 10, "B": 11}
def get_note(name):
    if name == "R":
        return Note(-1, 1/8)

    if name == "H":
        return nil

    var level
    var note_offset
    var note_name = ""
    level = ord(name[len(name) - 1]) - ord("0")
    var i
    for i = 0 to len(name) - 1:
        note_name = note_name + name[i]
    note_offset = pitch_map[note_name]
    var pitch = 12 * (level + 1) + note_offset
    var note = Note(pitch, 1/8)
    # display "get_note", name, note_name, level, pitch
    return note

class Meter:
    var measure
    var beat

    # measure: number of beats in a measure
    # beat: (beat)th note equals a beat 
    def init(measure_, beat_):
        measure = measure_
        beat = beat_

class Rythm:
    var rtype
    var _channel
    var note_queue
    var _next_time # count by beats
    var meter
    var length # count by measures

    def init(channel_, start_time_, meter_, type_):
        _channel = channel_
        _next_time = start_time_
        note_queue = Queue()
        meter = meter_
        length = 0
        rtype = type_

    def add_note(note, stress):
        if stress:
            note.velocity = 180
        else:
            note.velocity = 110

        note._channel = _channel
        note.graphic_time = _next_time
        note_queue.push(note)
        _next_time = _next_time + note.duration * meter.beat
        length = length + note.duration

    def add_chord(chord, stress):
        var velocity
        if stress:
            velocity = 180
        else:
            velocity = 110

        var i
        for i = 0 to len(chord):
            var note = chord[i]
            note.velocity = velocity
            note._channel = _channel
            note.graphic_time = _next_time
            note_queue.push(note)

        _next_time = _next_time + chord[0].duration * meter.beat
        length = length + chord[0].duration

    def time_advance(val):
        _next_time = _next_time - val
        var i
        for i = 0 to note_queue.size():
            var note = note_queue.get(i)
            note.graphic_time = note.graphic_time - val
            note_queue.set(i, note)

    def size():
        return note_queue.size()

    def dispatch_note():
        var note = note_queue.pop()
        length = length - note.duration
        return note

    def get_recent_notes():
        var cnt = 0.0
        var idx = 0
        var notes = []
        while idx < note_queue.size() and note_queue.get(idx).graphic_time < meter.measure:
            var tmp = note_queue.get(idx)
            if tmp.pitch >= 0:
                notes.append(tmp)
            idx = idx + 1
        return notes

def choose_or_not(prob):
    var rand = random()
    if rand < prob:
        return 1
    else:
        return 0


